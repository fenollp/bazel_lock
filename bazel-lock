#!/bin/sh -u

[ $# -ne 1 ] && echo "Usage: $0  <target to upgrade>" && exit 1

# This tool is just to demonstrate a possible usage.
# Ideally this is part of Bazel itself, replacing these hacks.

BAZEL=${BAZEL:-bazel}
W=WORKSPACE
L=LOCKFILE.bzl
#${BUILD_WORKSPACE_DIRECTORY:-} set when running inside Bazel

GetStringField() {
	git grep -h -A999 -F "name = \"$1\"," -- $W \
	| grep -F "    $2 = " \
	| awk -v FS='"' '{print $2}'
}

Pin() {
	printf 'locked["%s"] = {%s}\n' "$1" "$2" >>$L
}

KeyHTTPArchive() {
    url=$1; shift
    upgrades_slug=$1; shift
    upgrade_constraint=$1; shift
    echo "http_archive> $url $upgrades_slug $upgrade_constraint"
}

KeyGitRepository() {
    tag=$1; shift
    branch=$1; shift
    remote=$1; shift
    echo "git_repository> $tag $branch $remote"
}

GitHubCurl() {
	o=$1; shift
	if [ -n "${GITHUB_TOKEN:-}" ]; then
		curl -#fSLo "$o" -H "authorization: token $GITHUB_TOKEN" "$@"
	else
		curl -#fSLo "$o" "$@"
	fi
}

FilterSemVer() {
	filter=$1; shift
	script=$(mktemp)
	{
		echo 'from __future__ import print_function'
		echo 'import sys'
	} >"$script"
	#https://raw.githubusercontent.com/rbarrois/python-semanticversion/eda1ac8c22a99dbd01cd57fbcd459856b469ae46/semantic_version/base.py
	cat "$(dirname "$0")"/semantic_version-eda1ac8c22a99dbd01cd57fbcd459856b469ae46.py >>"$script"
	{
		echo 'versions = {}'
		echo 'for line in sys.stdin:'
		echo '    version, url = line.rstrip().split(" ", 1)'
		echo '    versions[Version.coerce(version)] = url'
		echo 'selected = SimpleSpec(sys.argv[1]).select(versions)'
		echo 'if not selected:'
		echo '    exit(42)'
		echo 'print(versions[selected])'
	} >>"$script"
	python "$script" "$filter"
	err=$?
	rm "$script"
	return $err
}

errcode=0

if [ ! -f $W ]; then
	echo "No Bazel $W in $PWD"
	errcode=1
fi
[ $errcode -ne 0 ] && exit $errcode

echo 'locked = {}' >$L

# Upgrade what needs to be resolved
# shellcheck disable=SC2013
for name in $(grep -A1 -F 'http_archive(' -- $W | grep -F ' name = ' | awk -v FS='"' '{print $2}'); do
	upgrades_slug=$(GetStringField "$name" upgrades_slug || '')
	[ -z "$upgrades_slug" ] && continue
	kind=http_archive; echo "Upgrading $kind(name = \"$name\", ...)"
	gh_releases_url=https://api.github.com/repos/"$upgrades_slug"/releases
	curled=$(mktemp)
	if ! GitHubCurl "$curled" "$gh_releases_url"; then
		rm "$curled"
		echo "Failed fetching $gh_releases_url"
		errcode=1
		continue
	fi
	upgrade_constraint=$(GetStringField "$name" upgrade_constraint || '')
	url=$( (cat "$curled" && rm "$curled") \
		| jq '.[] | select( .draft == false and .prerelease == false ) | .assets[] | .browser_download_url' \
		| jq    ". | select(endswith(\"$(GetStringField "$name" type || '')\"))" \
		| jq -r ". | select(endswith(\"$(GetStringField "$name" upgrade_constraint_url_contains || '')\"))" \
		| while read -r gh_url; do
			# Extract & deduplicate version-like strings
			echo "$(echo "$gh_url" | grep -Eo '[0-9]+(\.[0-9]+)+' | sort -u) $gh_url"
		done \
		| FilterSemVer "$upgrade_constraint")
	if [ -z "$url" ]; then
		echo "No release of $upgrades_slug match constraints $upgrade_constraint"
		errcode=1
		continue
	fi
	Pin "$(KeyHTTPArchive '' "$upgrades_slug" "$upgrade_constraint")" "\"url\": \"$url\""
done
[ $errcode -ne 0 ] && exit $errcode

# Run build
txt=$(mktemp)
$BAZEL clean --expunge >/dev/null 2>&1 || true
$BAZEL build "$@" >"$txt" 2>&1
errcode=$?
if [ $errcode -ne 0 ]; then
	cat $L
	cat "$txt"
	rm "$txt"
	echo "Failed to run $BAZEL build $*"
	exit $errcode
fi

# Catch reproduciblility suggestions
(cat "$txt" && rm "$txt") \
| grep -F 'indicated that a canonical reproducible form can be obtained' \
| while read -r line; do
	name=$(echo "$line" | awk -v FS="'" '{print $2}')

	pinned=$(echo "$line" \
			| awk -v FS='and dropping' '{print $1}' \
			| awk -v FS='modifying arguments' '{print $2}' \
			| sed -E 's% ([^ ]+) =% "\1":%g')
	pinned=${pinned# }
	pinned=${pinned% }

	kind=$(git grep -h -B1 -F "name = \"$name\"," -- $W | head -n1 | sed 's%(%%')
	case "$kind" in
		http_archive)
			url=$(GetStringField "$name" url || '')
			upgrades_slug=$(GetStringField "$name" upgrades_slug || '')
			upgrade_constraint=$(GetStringField "$name" upgrade_constraint || '')
			key="$(KeyHTTPArchive "$url" "$upgrades_slug" "$upgrade_constraint")"
			# If upgraded, use lockfile to resolve url
			if [ -z "$url" ]; then
				Pin "$key" "\"url\": locked[\"$key\"][\"url\"], $pinned"
			else
				Pin "$key" "$pinned"
			fi
			;;
		git_repository)
			tag=$(GetStringField "$name" tag)
			branch=$(GetStringField "$name" branch)
			remote=$(GetStringField "$name" remote)
			Pin "$(KeyGitRepository	"$tag" "$branch" "$remote")" "$pinned"
			;;
		*)
			echo "Unhandled rule '$kind'" && exit 2
	esac
	echo "Locked $kind(name = \"$name\", ...)"
done

pretty=$(mktemp)
cat << EOF >"$pretty"
from __future__ import print_function
import json
EOF
cat $L >>"$pretty"
cat << EOF >>"$pretty"
print('locked = {}')
for k in sorted(locked):
	# Uses json.dumps to fmt with double quotes
	v = json.dumps(locked[k], sort_keys=True)
	k = json.dumps(k)
	print('locked[{}] = {}'.format(k, v))
EOF
python "$pretty" >$L
errcode=$?
rm "$pretty"
exit $errcode
