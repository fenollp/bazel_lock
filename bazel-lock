#!/bin/sh -u

[ $# -ne 1 ] && echo "Usage: $0  <target to upgrade>" && exit 1

# This tool is just to demonstrate a possible usage.
# Ideally this is part of Bazel itself, replacing these hacks.

BAZEL=${BAZEL:-bazel}
W=WORKSPACE
L=LOCKFILE.bzl
#${BUILD_WORKSPACE_DIRECTORY:-} set when running inside Bazel

GetFirstOfListField() {
	name=$1; shift
	field=$1; shift
	grep -m1 -h -A999 -F "name = \"$name\"," $W \
	| while read -r line; do [ ')' = "$line" ] && break; echo "$line"; done \
	| grep -m1 -A1 -E "^$field = \[" \
	| awk -v FS='"' '{print $2}' \
	| while read -r s; do [ -n "$s" ] && echo "$s"; done
}

GetStringField() {
	name=$1; shift
	field=$1; shift
	value=$(grep -m1 -h -A999 -F "name = \"$name\"," $W \
		| while read -r line; do [ ')' = "$line" ] && break; echo "$line"; done \
		| grep -m1 -E "^$field = \"" \
		| awk -v FS='"' '{print $2}')
	if [ "$field" = url ] && [ -z "$value" ]; then
		GetFirstOfListField "$name" urls
	else
		echo "$value"
	fi
}

Pin() {
	printf 'locked["%s"] = {%s}\n' "$1" "$2" >>$L
}

KeyHTTPArchive() {
    url=$1; shift
    type=$1; shift
    upgrades_slug=$1; shift
    upgrade_constraint=$1; shift
    upgrade_constraint_url_contains=$1; shift
    echo "http_archive> $url $type $upgrades_slug $upgrade_constraint $upgrade_constraint_url_contains"
}

KeyGitRepository() {
    tag=$1; shift
    branch=$1; shift
    remote=$1; shift
    echo "git_repository> $tag $branch $remote"
}

GitHubCurl() {
	o=$1; shift
	if [ -n "${GITHUB_TOKEN:-}" ]; then
		curl -#fSLo "$o" -H "authorization: token $GITHUB_TOKEN" "$@"
	else
		curl -#fSLo "$o" "$@"
	fi
}

FilterSemVer() {
	filter=$1; shift
	script=$(mktemp)
	{
		echo 'from __future__ import print_function'
		echo 'import sys'
	} >"$script"
	#https://raw.githubusercontent.com/rbarrois/python-semanticversion/eda1ac8c22a99dbd01cd57fbcd459856b469ae46/semantic_version/base.py
	cat "$(dirname "$0")"/semantic_version-eda1ac8c22a99dbd01cd57fbcd459856b469ae46.py >>"$script"
	{
		echo 'versions = {}'
		echo 'for line in sys.stdin:'
		echo '    version_and_url = line.rstrip().split(" ", 1)'
		echo '    if len(version_and_url) != 2:'
		echo '        for version, url in versions.items():'
		echo '            print("{} {}".format(version, url), file=sys.stderr)'
		echo '        print("Bad version/URL: {}".format(version_and_url), file=sys.stderr)'
		echo '        exit(42)'
		echo '    version, url = version_and_url'
		echo '    versions[Version.coerce(version)] = url'
		echo 'selected = SimpleSpec(sys.argv[1]).select(versions)'
		echo 'if not selected:'
		echo '    exit(42)'
		echo 'print(versions[selected])'
	} >>"$script"
	python "$script" "$filter"
	err=$?
	rm "$script"
	return $err
}

errcode=0

if [ ! -f $W ]; then
	echo "No Bazel $W in $PWD" >&2
	errcode=1
fi
[ $errcode -ne 0 ] && exit $errcode

echo 'locked = {}' >$L

# Upgrade what needs to be resolved
echo 'Upgrading dependencies...'
# shellcheck disable=SC2043
for kind in http_archive; do
	# shellcheck disable=SC2013
	for name in $(grep -A1 -F "$kind(" $W | grep -F ' name = ' | awk -v FS='"' '{print $2}'); do
		url=$(GetStringField "$name" url)
		[ -n "$url" ] && continue
		upgrades_slug=$(GetStringField "$name" upgrades_slug)
		[ -z "$upgrades_slug" ] && continue
		echo "Upgrading $kind(name = \"$name\", ...)"
		type=$(GetStringField "$name" type)
		upgrade_constraint=$(GetStringField "$name" upgrade_constraint)
		upgrade_constraint_url_contains=$(GetStringField "$name" upgrade_constraint_url_contains)
		if [ -z "$upgrade_constraint" ]; then
			if [ -z "$type" ]; then
				echo "Missing 'type' field. Try: type = \"zip\"" >&2
				errcode=1
				continue
			fi
			case "${upgrades_slug%%/*}" in
			github.com)
				repo=git://$upgrades_slug.git
				HEAD=$(git ls-remote "$repo" | grep HEAD | awk '{print $1}')
				if [ -z "$HEAD" ]; then
					echo "Could not resolve HEAD of $repo: remote not responding." >&2
					errcode=1
					continue
				fi
				url=https://$upgrades_slug/archive/$HEAD.$type
				;;
			*)
				echo "Unsupported $kind slug: ${upgrades_slug%%/*}" >&2
				errcode=1
				continue
			esac
		else
			case "${upgrades_slug%%/*}" in
			github.com)
				gh_releases_url=https://api.github.com/repos/"${upgrades_slug#*/}"/releases
				curled=$(mktemp)
				if ! GitHubCurl "$curled" "$gh_releases_url"; then
					rm "$curled"
					echo "Failed fetching $gh_releases_url" >&2
					errcode=1
					continue
				fi
				url=$( (cat "$curled" && rm "$curled") \
					| jq '.[] | select( .draft == false and .prerelease == false ) | .assets[] | .browser_download_url' \
					| jq    ". | select(endswith(\"$type\"))" \
					| jq -r ". | select(endswith(\"$upgrade_constraint_url_contains\"))" \
					| while read -r gh_url; do
						# Extract & deduplicate version-like strings
						echo "$(echo "${gh_url%.*}" | grep -Eo '[0-9]+(\.[0-9]+)+' | sort -u) $gh_url"
					done \
					| FilterSemVer "$upgrade_constraint")
				if [ -z "$url" ]; then
					echo "No release of $upgrades_slug match constraints $upgrade_constraint" >&2
					errcode=1
					continue
				fi
				;;
			*)
				echo "Unsupported $kind slug: ${upgrades_slug%%/*}. Maybe use git_repository()?" >&2
				# TODO? git ls-remote + git archive (really should be using git_repository)
				errcode=1
				continue
			esac
		fi
		echo "Selected @$name's URL:"
		echo "$kind("
		echo "    name = \"$name\","
		[ -n "$type" ] && echo "    type = \"$type\","
		echo "    upgrades_slug = \"$upgrades_slug\","
		[ -n "$upgrade_constraint" ] && echo "    upgrade_constraint = \"$upgrade_constraint\","
		[ -n "$upgrade_constraint_url_contains" ] && echo "    upgrade_constraint_url_contains = \"$upgrade_constraint_url_contains\","
		echo "    ..."
		echo "    url = \"$url\","
		echo ")"
		echo
		Pin "$(KeyHTTPArchive '' "$type" "$upgrades_slug" "$upgrade_constraint" "$upgrade_constraint_url_contains")" "\"url\": \"$url\""
	done
done
[ $errcode -ne 0 ] && exit $errcode

# Run build
echo 'Cleaning some Bazel state...'
$BAZEL clean --expunge >/dev/null 2>&1 || true
echo 'Locking repositories...'
txt=$(mktemp)
$BAZEL build "$@" 2>&1 | tee "$txt"
errcode=$?
if [ $errcode -ne 0 ]; then
	echo 'Failed while locking!' >&2
	cat $L >&2
	cat "$txt" >&2
	rm "$txt"
	echo "Failed to run $BAZEL build $*" >&2
	exit $errcode
fi

# Catch reproduciblility suggestions
(cat "$txt" && rm "$txt") \
| grep -F 'indicated that a canonical reproducible form can be obtained' \
| while read -r line; do
	name=$(echo "$line" | awk -v FS="'" '{print $2}')

	pinned=$(echo "$line" \
			| awk -v FS='and dropping' '{print $1}' \
			| awk -v FS='modifying arguments' '{print $2}' \
			| sed -E 's% ([^ ]+) =% "\1":%g')
	pinned=${pinned# }
	pinned=${pinned% }

	kind=$(grep -m1 -h -B1 -F "name = \"$name\"," $W | head -n1 | sed 's%(%%')
	case "$kind" in
		http_archive)
			url=$(GetStringField "$name" url)
			type=$(GetStringField "$name" type)
			upgrades_slug=$(GetStringField "$name" upgrades_slug)
			upgrade_constraint=$(GetStringField "$name" upgrade_constraint)
			upgrade_constraint_url_contains=$(GetStringField "$name" upgrade_constraint_url_contains)
			key="$(KeyHTTPArchive "$url" "$type" "$upgrades_slug" "$upgrade_constraint" "$upgrade_constraint_url_contains")"
			# If upgraded, use lockfile to resolve url
			if [ -z "$url" ]; then
				Pin "$key" "\"url\": locked[\"$key\"][\"url\"], $pinned"
			else
				Pin "$key" "$pinned"
			fi
			;;
		git_repository)
			tag=$(GetStringField "$name" tag)
			branch=$(GetStringField "$name" branch)
			remote=$(GetStringField "$name" remote)
			Pin "$(KeyGitRepository	"$tag" "$branch" "$remote")" "$pinned"
			;;
		*)
			echo "Unhandled rule '$kind'" && exit 2
	esac
	echo "Pinned @$name"
done

echo Finishing up...
script=$(mktemp)
cat << EOF >"$script"
from __future__ import print_function
import json
EOF
cat $L >>"$script"
cat << EOF >>"$script"
print('locked = {}')
for k in sorted(locked):
	# Uses json.dumps to fmt with double quotes
	v = json.dumps(locked[k], sort_keys=True)
	k = json.dumps(k)
	print('locked[{}] = {}'.format(k, v))
EOF
pretty=$(mktemp)
python "$script" >"$pretty"
errcode=$?
rm "$script"
[ $errcode -ne 0 ] && rm "$pretty" && exit $errcode
mv "$pretty" $L
