#!/bin/sh -ux

[ $# -ne 1 ] && echo "Usage: $0  <target to upgrade>" && exit 1
target=$1

# This tool is just to demonstrate a possible usage.
# Ideally this is part of Bazel itself, replacing these hacks.

BAZEL=${BAZEL:-bazel}
W=WORKSPACE
L=LOCKFILE.bzl

GetStringField() {
	git grep -h -A999 -F "name = \"$1\"," -- $W \
	| grep -F "    $2 = " \
	| awk -v FS='"' '{print $2}'
}

Pin() {
	printf 'locked["%s"] = {%s}\n' "$1" "$2" >>$L
}

GitHubCurl() {
	if [ -n "${GITHUB_TOKEN:-}" ]; then
		curl -#fSL -H "Authorization: token $GITHUB_TOKEN" "$@"
	else
		curl -#fSL "$@"
	fi
}

errcode=0

if [ ! -f $W ]; then
	echo "No Bazel $W in $PWD"
	errcode=1
fi
[ $errcode -ne 0 ] && exit $errcode

echo 'locked = {}' >$L

# Upgrade what needs to be resolved
# shellcheck disable=SC2013
for name in $(grep -A1 -F 'http_archive(' -- $W | grep -F ' name = ' | awk -v FS='"' '{print $2}'); do
	upgrades_slug=$(GetStringField "$name" upgrades_slug || '')
	[ -z "$upgrades_slug" ] && continue
	type=$(GetStringField "$name" type || '')
	upgrade_constraint=$(GetStringField "$name" upgrade_constraint || '') # TODO: enforce contraint
	gh_releases_url=https://api.github.com/repos/"$upgrades_slug"/releases
	url=$(GitHubCurl "$gh_releases_url" \
		| jq -r '.[] | select( .draft == false and .prerelease == false ) | .assets[] | .browser_download_url' \
		| grep "$type$" \
		| head -n1)
	if [ -z "$url" ]; then
		echo "Failed fetching $gh_releases_url"
		errcode=1
	fi
	Pin "http_archive>  $upgrades_slug $upgrade_constraint" "\"url\": \"$url\""
done
[ $errcode -ne 0 ] && exit $errcode

# Run build
txt=$(mktemp)
dir=$(mktemp -d)
$BAZEL --output_user_root="$dir" build "$target" >"$txt" 2>&1
errcode=$?
rm -rf "$dir" >/dev/null 2>&1 || true  # Silence errors for Windows
if [ $errcode -ne 0 ]; then
	cat $L
	cat "$txt"
	rm "$txt"
	echo "Failed to run $BAZEL build $target"
	exit $errcode
fi

# Catch reproduciblility suggestions
(cat "$txt" && rm "$txt") \
| grep -F 'indicated that a canonical reproducible form can be obtained' \
| while read -r line; do
	name=$(echo "$line" | awk -v FS="'" '{print $2}')

	pinned=$(echo "$line" \
			| awk -v FS='and dropping' '{print $1}' \
			| awk -v FS='modifying arguments' '{print $2}' \
			| sed -E 's% ([^ ]+) =% "\1":%g')
	pinned=${pinned# }
	pinned=${pinned% }

	kind=$(git grep -h -B1 -F "name = \"$name\"," -- $W | head -n1 | sed 's%(%%')
	case "$kind" in
		http_archive)
			url=$(GetStringField "$name" url || '')
			upgrades_slug=$(GetStringField "$name" upgrades_slug || '')
			upgrade_constraint=$(GetStringField "$name" upgrade_constraint || '')
			key="$kind> $url $upgrades_slug $upgrade_constraint"
			# If upgraded, use lockfile to resolve url
			if [ -z "$url" ]; then
				Pin "$key" "\"url\": locked[\"$key\"][\"url\"], $pinned"
			else
				Pin "$key" "$pinned"
			fi
			;;
		git_repository)
			tag=$(GetStringField "$name" tag)
			branch=$(GetStringField "$name" branch)
			remote=$(GetStringField "$name" remote)
			Pin "$kind> $tag $branch $remote" "$pinned"
			;;
		*)
			echo "Unhandled rule '$kind'" && exit 2
	esac
	echo "Locked $kind(name = \"$name\", ...)"
done

pretty=$(mktemp)
cat << EOF >"$pretty"
from __future__ import print_function
import json
EOF
cat $L >>"$pretty"
cat << EOF >>"$pretty"
print('locked = {}')
for k in sorted(locked):
	# Uses json.dumps to fmt with double quotes
	v = json.dumps(locked[k], sort_keys=True)
	k = json.dumps(k)
	print('locked[{}] = {}'.format(k, v))
EOF
python "$pretty" >$L
errcode=$?
rm "$pretty"
exit $errcode
