#!/bin/sh -u

[ $# -ne 1 ] && echo "Usage: $0  <target to upgrade>" && exit 1

# This tool is just to demonstrate a possible usage.
# Ideally this is part of Bazel itself, replacing these hacks.

BAZEL=${BAZEL:-bazel}
W=WORKSPACE
L=LOCKFILE.bzl

GetStringField() {
	git grep -h -A999 -F "name = \"$1\"," -- $W \
	| grep -F "    $2 = " \
	| awk -v FS='"' '{print $2}'
}

Pin() {
	printf 'locked["%s"] = {%s}\n' "$1" "$2" >>$L
}

KeyHTTPArchive() {
    url=$1; shift
    upgrades_slug=$1; shift
    upgrade_constraint=$1; shift
    echo "http_archive> $url $upgrades_slug $upgrade_constraint"
}

KeyGitRepository() {
    tag=$1; shift
    branch=$1; shift
    remote=$1; shift
    echo "git_repository> $tag $branch $remote"
}

GitHubCurl() {
	o=$1; shift
	if [ -n "${GITHUB_TOKEN:-}" ]; then
		curl -#fSLo "$o" -H "authorization: token $GITHUB_TOKEN" "$@"
	else
		curl -#fSLo "$o" "$@"
	fi
}

errcode=0

if [ ! -f $W ]; then
	echo "No Bazel $W in $PWD"
	errcode=1
fi
[ $errcode -ne 0 ] && exit $errcode

echo 'locked = {}' >$L

# Upgrade what needs to be resolved
# shellcheck disable=SC2013
for name in $(grep -A1 -F 'http_archive(' -- $W | grep -F ' name = ' | awk -v FS='"' '{print $2}'); do
	upgrades_slug=$(GetStringField "$name" upgrades_slug || '')
	[ -z "$upgrades_slug" ] && continue
	kind=http_archive; echo "Upgrading $kind(name = \"$name\", ...)"
	upgrade_constraint=$(GetStringField "$name" upgrade_constraint || '') # TODO: enforce contraint
	gh_releases_url=https://api.github.com/repos/"$upgrades_slug"/releases
	curled=$(mktemp)
	if ! GitHubCurl "$curled" "$gh_releases_url"; then
		rm "$curled"
		echo "Failed fetching $gh_releases_url"
		errcode=1
		continue
	fi
	url=$(jq '.[] | select( .draft == false and .prerelease == false ) | .assets[] | .browser_download_url' \
		<"$curled" \
		| jq ". | select(endswith(\"$(GetStringField "$name" type || '')\"))" \
		| jq -r . \
		| head -n1)
	rm "$curled"
	if [ -z "$url" ]; then
		echo "No release of $upgrades_slug match constraints $upgrade_constraint"
		errcode=1
		continue
	fi
	Pin "$(KeyHTTPArchive '' "$upgrades_slug" "$upgrade_constraint")" "\"url\": \"$url\""
done
[ $errcode -ne 0 ] && exit $errcode

# Run build
txt=$(mktemp)
$BAZEL clean --expunge >/dev/null 2>&1 || true
$BAZEL build "$@" >"$txt" 2>&1
errcode=$?
if [ $errcode -ne 0 ]; then
	cat $L
	cat "$txt"
	rm "$txt"
	echo "Failed to run $BAZEL build $@"
	exit $errcode
fi

# Catch reproduciblility suggestions
(cat "$txt" && rm "$txt") \
| grep -F 'indicated that a canonical reproducible form can be obtained' \
| while read -r line; do
	name=$(echo "$line" | awk -v FS="'" '{print $2}')

	pinned=$(echo "$line" \
			| awk -v FS='and dropping' '{print $1}' \
			| awk -v FS='modifying arguments' '{print $2}' \
			| sed -E 's% ([^ ]+) =% "\1":%g')
	pinned=${pinned# }
	pinned=${pinned% }

	kind=$(git grep -h -B1 -F "name = \"$name\"," -- $W | head -n1 | sed 's%(%%')
	case "$kind" in
		http_archive)
			url=$(GetStringField "$name" url || '')
			upgrades_slug=$(GetStringField "$name" upgrades_slug || '')
			upgrade_constraint=$(GetStringField "$name" upgrade_constraint || '')
			key="$(KeyHTTPArchive "$url" "$upgrades_slug" "$upgrade_constraint")"
			# If upgraded, use lockfile to resolve url
			if [ -z "$url" ]; then
				Pin "$key" "\"url\": locked[\"$key\"][\"url\"], $pinned"
			else
				Pin "$key" "$pinned"
			fi
			;;
		git_repository)
			tag=$(GetStringField "$name" tag)
			branch=$(GetStringField "$name" branch)
			remote=$(GetStringField "$name" remote)
			Pin "$(KeyGitRepository	"$tag" "$branch" "$remote")" "$pinned"
			;;
		*)
			echo "Unhandled rule '$kind'" && exit 2
	esac
	echo "Locked $kind(name = \"$name\", ...)"
done

pretty=$(mktemp)
cat << EOF >"$pretty"
from __future__ import print_function
import json
EOF
cat $L >>"$pretty"
cat << EOF >>"$pretty"
print('locked = {}')
for k in sorted(locked):
	# Uses json.dumps to fmt with double quotes
	v = json.dumps(locked[k], sort_keys=True)
	k = json.dumps(k)
	print('locked[{}] = {}'.format(k, v))
EOF
python "$pretty" >$L
errcode=$?
rm "$pretty"
exit $errcode
