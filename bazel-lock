#!/bin/sh -u

[ $# -ne 1 ] && echo "Usage: $0  <target to upgrade>" && exit 1
target=$1

# This tool is just to demonstrate a possible usage.
# Ideally this is part of Bazel itself, replacing these hacks.

BAZEL=${BAZEL:-bazel}
W=WORKSPACE
L=LOCKFILE.bzl

GetStringField() {
	git grep -h -A999 -F "name = \"$1\"," -- $W \
	| grep -F "    $2 = " \
	| awk -v FS='"' '{print $2;}'
}

Pin() {
	printf 'locked["%s"] = {%s}\n' "$1" "$2" >>$L
}

errcode=0

if [ ! -f $W ]; then
	echo "No Bazel $W in $PWD"
	errcode=1
fi
[ $errcode -ne 0 ] && exit $errcode

echo 'locked = {}' >$L

# Upgrade what needs to be resolved
# shellcheck disable=SC2013
for name in $(grep -A1 -F 'http_archive(' -- $W | grep -F ' name = ' | awk -v FS='"' '{print $2}'); do
	upgrades_slug=$(GetStringField "$name" upgrades_slug || '')
	[ -z "$upgrades_slug" ] && continue
	type=$(GetStringField "$name" type || '')
	github_releases=https://api.github.com/repos/"$upgrades_slug"/releases
	url=$(curl -#fSL "$github_releases" \
		| jq -r '.[] | select( .draft == false and .prerelease == false ) | .assets[] | .browser_download_url' \
		| grep "$type$" \
		| head -n1)
	if [ -z "$url" ]; then
		echo "Failed fetching $github_releases"
		errcode=1
	fi
	# TODO: upgrade_constraint=$(GetStringField "$name" upgrade_constraint || '')
	Pin "$name" "\"url\": \"$url\""
done
[ $errcode -ne 0 ] && exit $errcode

# Run build
txt=$(mktemp)
dir=$(mktemp -d)
$BAZEL --output_user_root="$dir" build "$target" >"$txt" 2>&1
errcode=$?
rm -rf "$dir" >/dev/null 2>&1 || true  # Silence errors for Windows
if [ $errcode -ne 0 ]; then
	cat $L
	cat "$txt"
	rm "$txt"
	echo "Failed to run $BAZEL build $target"
	exit $errcode
fi

# Catch reproduciblility suggestions
(cat "$txt" && rm "$txt") \
| grep -F 'indicated that a canonical reproducible form can be obtained' \
| while read -r line; do
	name=$(echo "$line" | awk -v FS="'" '{print $2;}')

	pinned=$(echo "$line" \
			| awk -v FS='and dropping' '{print $1;}' \
			| awk -v FS='modifying arguments' '{print $2;}' \
			| sed -E 's% ([^ ]+) =% "\1":%g')
	pinned=${pinned# }
	pinned=${pinned% }

	kind=$(git grep -h -B1 -F "name = \"$name\"," -- $W | head -n1 | sed 's%(%%')
	if [ "$kind" = 'http_archive' ]; then
		url=$(GetStringField "$name" url || '')
		# If upgraded, use lockfile to resolve url
		[ -z "$url" ] && pinned="\"url\": locked[\"$name\"][\"url\"], $pinned"
	fi
	Pin "$name" "$pinned"
	echo "Locked $kind(name = \"$name\", ...)"
done

pretty=$(mktemp)
cat << EOF >"$pretty"
from __future__ import print_function
import json
EOF
cat $L >>"$pretty"
cat << EOF >>"$pretty"
print('locked = {}')
for k in sorted(locked):
	# Uses json.dumps to fmt with double quotes
	v = json.dumps(locked[k], sort_keys=True)
	k = json.dumps(k)
	print('locked[{}] = {}'.format(k, v))
EOF
python "$pretty" >$L
errcode=$?
rm "$pretty"
exit $errcode
